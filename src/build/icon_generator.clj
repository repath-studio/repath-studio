(ns build.icon-generator
  "Shadow-cljs build hook that watches src/icons for SVG files and generates a
   defaults.cljs namespace containing all icons."
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string])
  (:import
   [java.io File]
   [java.nio.file FileSystems StandardWatchEventKinds WatchService]))

(defn svg-files!
  [icons-dir]
  (->> (.listFiles (io/file icons-dir))
       (filter #(string/ends-with? (.getName ^File %) ".svg"))
       (sort-by #(.getName ^File %))))

(defn extract-path
  [svg-content]
  (when-let [match (re-find #"<path[^>]*\sd=\"([^\"]+)\"" svg-content)]
    (second match)))

(defn svg-file->icon-id
  [^File f]
  (-> (.getName f)
      (string/replace #"\.svg$" "")))

(defn parse-icon
  [^File f]
  (let [content (slurp f)
        path-d (extract-path content)
        id (svg-file->icon-id f)]
    (when path-d
      [id {:id id
           :path path-d}])))

(defn generate-icons-map!
  [icons-dir]
  (->> (svg-files! icons-dir)
       (keep parse-icon)
       (into (sorted-map))))

(defn format-icon-entry
  [[id {:keys [path]}]]
  (str (pr-str id) "\n"
       "   {:id " (pr-str id) "\n"
       "    :path " (pr-str path) "}"))

(defn generate-source
  [icons-map]
  (let [entries (map format-icon-entry icons-map)]
    (str ";; ============================================================\n"
         ";; AUTO-GENERATED â€” DO NOT EDIT\n"
         ";; Generated by build.icon-generator from src/icons/*.svg\n"
         ";; ============================================================\n"
         "(ns renderer.icon.defaults)\n"
         "\n"
         "#_{:clj-kondo/ignore [:line-length]}\n"
         "(def icons\n"
         "  {" (string/join "\n\n   " entries) "})\n")))

(defn icons-dir-path! []
  (io/file "src" "icons"))

(defn output-file-path! []
  (io/file "src" "renderer" "icon" "defaults.cljs"))

(defn generate! []
  (let [icons-dir (icons-dir-path!)
        output (output-file-path!)
        icons-map (generate-icons-map! icons-dir)
        new-source (generate-source icons-map)
        changed? (or (not (.exists output))
                     (not= (slurp output) new-source))]
    (when changed?
      (spit output new-source)
      (println (str "[icon-generator] Generated " (count icons-map)
                    " icons -> " (.getPath output))))
    changed?))

(defonce ^:private watcher-state (atom nil))

(defn stop-watcher! []
  (when-let [{:keys [^WatchService watch-service ^Thread
                     thread]} @watcher-state]
    (println "[icon-generator] Stopping icon watcher")
    (.close watch-service)
    (.interrupt thread)
    (reset! watcher-state nil)))

(defn svg-file?
  [^java.nio.file.WatchEvent event]
  (string/ends-with? (str (.context event)) ".svg"))

(defn start-watcher!
  "Starts a thread that watches SVG files under src/icons and regenerate the
   output file when a change is detected,"
  []
  (stop-watcher!)
  (let [icons-dir (.toPath (.getAbsoluteFile (icons-dir-path!)))
        ws (.newWatchService (FileSystems/getDefault))
        _ (.register icons-dir ws
                     (into-array [StandardWatchEventKinds/ENTRY_CREATE
                                  StandardWatchEventKinds/ENTRY_MODIFY
                                  StandardWatchEventKinds/ENTRY_DELETE]))
        thread (Thread.
                (fn []
                  (println "[icon-generator] Watching SVG icons under "
                           (str icons-dir))
                  (try
                    (loop []
                      (when-let [wk (.take ws)]
                        (let [events (.pollEvents wk)
                              svg? (some svg-file? events)]
                          (.reset wk)
                          (when svg?
                            (Thread/sleep 50) ;; debounce rapid events
                            (generate!))
                          (recur))))
                    (catch java.nio.file.ClosedWatchServiceException _)
                    (catch InterruptedException _))))]
    (doto thread
      (.setName "icon-generator-watcher")
      (.setDaemon true)
      (.start))
    (reset! watcher-state {:watch-service ws
                           :thread thread})))

(defn ^:export hook!
  {:shadow.build/stages #{:configure :compile-prepare}}
  [build-state & _args]
  (case (:shadow.build/stage build-state)
    :configure (do (start-watcher!)
                   (generate!)
                   build-state)
    :compile-prepare (do (generate!)
                         build-state)))
